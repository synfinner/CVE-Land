#!/usr/bin/env python3
import json
import hashlib
import secrets
import os.path
from flask import Flask, jsonify, request, session, redirect, render_template, flash
from flask_wtf.csrf import CSRFProtect
from gsd_database import GsdDatabase
import hashlib

app = Flask(__name__)
app.config['SECRET_KEY'] = 'CVE-LAND!!!'
csrf = CSRFProtect(app)
gsd_database = GsdDatabase(app)

def generate_salt():
    # Generate a secure random salt
    salt = secrets.token_hex(16)

    # Save the salt to a JSON file
    with open('salt.json', 'w') as f:
        json.dump({'salt': salt}, f)

    return salt

if not os.path.exists('salt.json'):
    generate_salt()
else:
    with open('salt.json', 'r') as f:
        salt = json.load(f)['salt']

# Load the tokens from the JSON file
with open('tokens.json', 'r') as f:
    tokens = json.load(f)
# Load the salt from the JSON file
with open('salt.json', 'r') as f:
    salt = json.load(f)['salt']

def get_flashed_messages():
    flashes = session.pop('_flashes', None)
    if flashes is None:
        return []
    return flashes

def hash_token(username, token):
    hashed_token = hashlib.sha256((salt + username + token).encode('utf-8')).hexdigest()
    return hashed_token

def requires_auth(f):
    def wrapper(*args, **kwargs):
        auth = request.headers.get('Authorization')
        if not auth:
            return 'Missing authorization header', 401
        auth_parts = auth.split(' ')
        if len(auth_parts) != 3 or auth_parts[0] != 'Bearer':
            return 'Invalid authorization header, lol', 401
        username = auth_parts[1]
        token = auth_parts[2]
        hashed_token = hash_token(username, token)
        if username not in tokens or hashed_token != tokens[username]['hashed_token']:
            return 'Invalid token, bro. Try again.', 401
        return f(*args, **kwargs)

    # Set the name of the wrapper function to the name of the decorated function
    wrapper.__name__ = f.__name__
    return wrapper

@app.route('/gsd-database/<cve>/baseScore',methods=['GET'])
@requires_auth
@csrf.exempt
def get_base_score(cve):
    base_score_value = gsd_database.get_base_score(cve)
    if base_score_value is None:
        return 'File not found', 404
    return jsonify(base_score_value)

@app.route('/gsd-database/<cve>',methods=['GET'])
@requires_auth
@csrf.exempt
def get_file(cve):
    data = gsd_database.get_file(cve)
    if data is None:
        return 'File not found', 404
    return jsonify(data)

@app.route('/admin', methods=['GET', 'POST'])
def admin_login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        if username == 'admin' and password == 'secret':
            session['admin'] = True
            return redirect('/admin/dashboard')
        else:
            flash('Invalid username or password')
    return render_template('admin_login.html')

@app.route('/admin/dashboard')
def admin_dashboard():
    if not session.get('admin'):
        return redirect('/admin')
    return render_template('admin_dashboard.html')

@app.route('/admin/tokens')
def admin_tokens():
    if not session.get('admin'):
        return redirect('/admin')
    user_tokens = []
    for user, token_data in tokens.items():
        if 'hashed_token' in token_data:
            user_tokens.append({'user': user, 'hashed_token': token_data['hashed_token']})
    deleted_token = session.pop('deleted_token', None)  # Retrieve and remove the deleted token from the session
    return render_template('admin_tokens.html', user_tokens=user_tokens, deleted_token=deleted_token)

@app.route('/admin/delete_token/<username>', methods=['POST'])
def delete_token(username):
    if not session.get('admin'):
        return redirect('/admin')
    if username in tokens:
        del tokens[username]
        with open('tokens.json', 'w') as f:
            json.dump(tokens, f, indent=2)
        flash(f'Token for {username} deleted successfully')
        session['deleted_token'] = username  # Store the deleted token in the session
    return redirect('/admin/tokens')

@app.route('/admin/new_token', methods=['GET', 'POST'])
def new_token():
    if not session.get('admin'):
        return redirect('/admin')
    if request.method == 'POST':
        username = request.form['username']

        # Check if a token already exists for the given user
        if username in tokens and 'hashed_token' in tokens[username]:
            flash('A token already exists for this user')
        else:
            # Generate a random token
            token = secrets.token_hex(16)

            # Hash the token using SHA-256 with the salt and the username
            hashed_token = hashlib.sha256((salt + username + token).encode('utf-8')).hexdigest()

            # Add the hashed token to the dictionary for the given username
            if username not in tokens:
                tokens[username] = {}
            tokens[username]['hashed_token'] = hashed_token

            # Save the dictionary to the tokens file
            with open('tokens.json', 'w') as f:
                json.dump(tokens, f)

            flash(f'New token has been created for user {username}')
            flash(f'The plain token for requests is: {token} - Keep it safe! This is the only time you will see it.')

    return render_template('new_token.html')

@app.route('/admin/logout')
def admin_logout():
    session.clear()
    return redirect('/admin')

@app.route('/')
def redirect_to_admin():
    return redirect('/admin')

if __name__ == '__main__':
    app.run(threaded=True, debug=False)
